/*
 * Copyright 2022 Sergey Lyashko
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 /* Grammar */
{
  parserClass="com.gllllepulla.plugin.parser.AsnParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Asn"
  psiImplClassSuffix="Impl"
  psiPackage="com.gllllepulla.plugin.psi"
  psiImplPackage="com.gllllepulla.plugin.psi.impl"

  elementTypeHolderClass="com.gllllepulla.plugin.psi.AsnTypes"
  elementTypeClass="com.gllllepulla.plugin.psi.AsnElementType"
  tokenTypeClass="com.gllllepulla.plugin.psi.AsnTokenType"

  tokens = [
        /* Global type */
        UNIVERSAL = "UNIVERSAL"
        APPLICATION = "APPLICATION"
        PRIVATE = "PRIVATE"
        CONTENT_SPECIFIC = "CONTENT-SPECIFIC"
        /* Construct definition */
        SET = "SET"
        EXTERNAL = "EXTERNAL"
        INSTANCE = "INSTANCE"
        SEQUENCE = "SEQUENCE"
        OF = "OF"
        BEGIN = "BEGIN"
        END = "END"
        DEFINITIONS = "DEFINITIONS"
        FROM = "FROM"
        CLASS_DEF = "CLASS"
        CHOICE = "CHOICE"
        IMPLICIT = "IMPLICIT"
        EXPLICIT = "EXPLICIT"
        SIZE = "SIZE"
        MAX = "MAX"
        MIN = "MIN"
        ENUMERATED = "ENUMERATED"
        WITH = "WITH"
        SYNTAX = "SYNTAX"
        /* universal type */
        ANY = "ANY"
        INTEGER = "INTEGER"
        NULL = "NULL"
        BOOLEAN = "BOOLEAN"
        OID = "OID"
        REAL = "REAL"
        OPTIONAL = "OPTIONAL"
        DEFAULT = "DEFAULT"
        UNIQUE = "UNIQUE"
        /* Bit string */
        OCTET = "OCTET STRING"
        BIT = "BIT STRING"
        /* Type string */
        STRING_NUM = "NumericString"
        STRING_PR = "PrintableString"
        STRING_TELE = "TeletextString"
        STRING_VTEXT = "VideotexString"
        STRING_VIS = "VisibleString"
        STRING_IA5 = "IA5String"
        STRING_GRAPH = "GraphicString"
        STRING_BMP = "BMPString"
        STRING_GEN = "GeneralString"
        STRING_UNI = "UniversalString"
        STRING_UTF8 = "UTF8String"
        STRING_CHAR = "CHARACTER STRING"
        /* other keywords */
        TAGS = "TAGS"
        EXPORTS = "EXPORTS"
        IMPORTS = "IMPORTS"
        CONTAINING = "CONTAINING"
        TYPE_IDENTIFIER = "TYPE-IDENTIFIER"
        /* brackets */
        LPAREN = "("
        RPAREN = ")"
        LBRACE = "{"
        RBRACE = "}"
        LBRACKET = "["
        RBRACKET = "]"
        /* Operators */
        ASSIGMENT = "::="
        VAR = "&"
        /* Symbols */
        COMMA = ","
        SEMICOLON = ";"
        COLON = ":"
        DOT = "."
        DOUBLE_DOT = ".."
        OR = "|"
        DOUBLE_QUOTE = "\""
        MINUS = "-"
        AT = "@"
        /* comments */
        COMMENT_LINE = "regexp:---.*"
        COMMENT_HEADER = "regexp:--.*"
        COMMENT_MULTILINE = "regexp:/\*[\s\S]*?\*/"
        /* Date and Time */
        TIME_UTC = "UTCTime"
        TIME_GEN = "GeneralizedTime"
        TIME = "TIME"
        TIME_OF_DAY = "TIME-OF-DAY"
        DATE = "DATE"
        DATE_TIME = "DATE-TIME"
        DURATION = "DURATION"
        /* Identifiers */
        USER_TYPE = "regexp:[A-Z]([-A-Z0-9]*[a-z]+[-A-Za-z0-9]*)+"
        VALUE_NAME = "regexp:\p{Ll}(-|\d|\p{Ll}|\p{Lu})*"
        TYPE_CLASS = "regexp:\p{Lu}(-|\p{Lu})*"
        /* Primitive */
        STR_LITERALS = "regexp:\"[^\"]*\""
        NUMBER_INT = "regexp:-?[0-9]+"
        NUMBER_FLOAT = "regexp:-?\d/.(\d)* "
        TRUE = "TRUE"
        FALSE = "FALSE"
        /* white space */
        NEW_LINE = "regexp:(\r|\n|\r\n)"
        WHITE_SPACE = "regexp:[\s\t\f\x0B]"
  ]

  generateTokenAccessors=true
}
program                         ::= property
property                        ::= NEW_LINE* file_header
file_header                     ::= (USER_TYPE|TYPE_CLASS) DEFINITIONS (IMPLICIT TAGS)? ASSIGMENT BEGIN exports_ imports_? constructs_* END { pin=4 }
/* elements */
values_                         ::= USER_TYPE|VALUE_NAME
int_round                       ::= LPAREN NUMBER_INT RPAREN
int_square                      ::= LBRACKET NUMBER_INT RBRACKET { pin=1 }
range_                          ::= LPAREN NUMBER_INT DOUBLE_DOT NUMBER_INT RPAREN
size_range                      ::= LPAREN SIZE (int_round|range_) RPAREN { pin=1 }
integer_range                   ::= INTEGER range_
type_string                     ::= STRING_NUM|STRING_PR|STRING_TELE| STRING_VTEXT|STRING_VIS|STRING_IA5|STRING_GRAPH|STRING_BMP|STRING_GEN|STRING_UNI|STRING_UTF8|STRING_CHAR
octet_                          ::= OCTET|BIT
bool_                           ::= BOOLEAN DEFAULT? (TRUE|FALSE)?
time_                           ::= TIME_UTC|TIME_GEN|TIME|TIME_OF_DAY|DATE|DATE_TIME|DURATION
element_                        ::= (USER_TYPE|type_string_size|time_|integer_range|primitive_def|octet_string|bool_) OPTIONAL?
primitive_def                   ::= INTEGER|REAL|NULL
primitive_                      ::= STR_LITERALS|NUMBER_INT|NUMBER_FLOAT
types_                          ::= TYPE_CLASS|USER_TYPE|OID
/* export & import */
exports_                        ::= EXPORTS (types_|values_) {COMMA (USER_TYPE|values_)}*  SEMICOLON { pin=1 }
imports_                        ::= IMPORTS from_* SEMICOLON
from_                           ::= (TYPE_CLASS|values_) {COMMA (TYPE_CLASS|values_)}* FROM USER_TYPE COMMA?
/* constructors */
constructs_                     ::= values_? (types_)? ASSIGMENT (primitive_|value_assigment) with_syntax? { pin=3 }
value_assigment                 ::= CLASS_DEF? (without_body|body_choice|body_enum|body_sequence|body_tagged)

with_syntax                     ::= WITH syntax_
syntax_                         ::= SYNTAX LBRACE descriptor_* RBRACE { pin=2 }
descriptor_                     ::= types_ VAR (VALUE_NAME|USER_TYPE)

type_string_size                ::= type_string size_range?
octet_string                    ::= octet_ size_range
/* no body */
without_body                    ::= seq_of? element_
seq_of                          ::= SEQUENCE OF
/* bodies */
body_choice                     ::= CHOICE LBRACE choice_def? {COMMA choice_def}* RBRACE { pin=2 }
choice_def                      ::= choice_element (seq_of|IMPLICIT|EXPLICIT)? (element_|body_enum)
choice_element                  ::= VALUE_NAME int_square?

body_enum                       ::= ENUMERATED LBRACE enum_element? {COMMA enum_element}* RBRACE OPTIONAL? { pin=2 }
enum_element                    ::= VALUE_NAME int_round

body_sequence                   ::= SEQUENCE LBRACE sequence_def? {COMMA sequence_def}* RBRACE { pin=2 }
sequence_def                    ::= seq_of_value|variables_inner_construct|id_tagged
seq_of_value                    ::= values_ seq_of USER_TYPE OPTIONAL?
variables_inner_construct       ::= (choice_def|inner_construct)
id_tagged                       ::= VALUE_NAME TYPE_CLASS DOT VAR values_ LPAREN singleton_body* RPAREN

body_tagged                     ::= LBRACE (variable_or|variables_|oid_|data_|seq_of_value|inner_construct)* RBRACE { pin=1 }
variable_or                     ::= VALUE_NAME {OR VALUE_NAME}*
oid_                            ::= OID (singleton_body|VALUE_NAME)
data_                           ::= TYPE_CLASS seq_of? (USER_TYPE|body_choice)
variables_                      ::= var_ {COMMA var_}*
var_                            ::= VAR values_? USER_TYPE? UNIQUE?
/* inner construct */
inner_construct                 ::= (choice_element|values_|TYPE_CLASS) (body_choice|body_enum)
singleton_body                  ::= LBRACE AT? (types_|VALUE_NAME) RBRACE

