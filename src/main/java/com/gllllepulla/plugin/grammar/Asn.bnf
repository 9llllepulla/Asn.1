/*
 * Copyright 2022 Sergey Lyashko
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 /* Grammar */
{
  parserClass="com.gllllepulla.plugin.parser.AsnParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Asn"
  psiImplClassSuffix="Impl"
  psiPackage="com.gllllepulla.plugin.psi"
  psiImplPackage="com.gllllepulla.plugin.psi.impl"

  elementTypeHolderClass="com.gllllepulla.plugin.psi.AsnTypes"
  elementTypeClass="com.gllllepulla.plugin.psi.AsnElementType"
  tokenTypeClass="com.gllllepulla.plugin.psi.AsnTokenType"

  tokens = [
        /* Global type */
        UNIVERSAL = "UNIVERSAL"
        APPLICATION = "APPLICATION"
        PRIVATE = "PRIVATE"
        CONTENT_SPECIFIC = "CONTENT-SPECIFIC"
        /* Construct definition */
        SET = "SET"
        EXTERNAL = "EXTERNAL"
        INSTANCE = "INSTANCE"
        SEQUENCE = "SEQUENCE"
        OF = "OF"
        BEGIN = "BEGIN"
        END = "END"
        DEFINITIONS = "DEFINITIONS"
        FROM = "FROM"
        CLASS = "CLASS"
        TAGGED = "TAGGED"
        ANY = "ANY"
        CHOICE = "CHOICE"
        IMPLICIT = "IMPLICIT"
        EXPLICIT = "EXPLICIT"
        SIZE = "SIZE"
        MAX = "MAX"
        MIN = "MIN"
        ENUMERATED = "ENUMERATED"
        WITH = "WITH"
        SYNTAX = "SYNTAX"
        /* universal type */
        INTEGER = "INTEGER"
        NULL = "NULL"
        BOOLEAN = "BOOLEAN"
        OID = "OID"
        RELATIVE_OID = "RELATIVE-OID"
        OID_IRI = "OID-IRI"
        RELATIVE_OID_IRI = "RELATIVE-OID-IRI"
        REAL = "REAL"
        OPTIONAL = "OPTIONAL"
        DEFAULT = "DEFAULT"
        UNIQUE = "UNIQUE"
        EOC = "EOC"
        /* Bit string */
        OCTET = "OCTET STRING"
        BIT = "BIT STRING"
        /* Type string */
        STRING_NUM = "NumericString"
        STRING_PR = "PrintableString"
        STRING_TELE = "TeletextString"
        STRING_VTEXT = "VideotexString"
        STRING_VIS = "VisibleString"
        STRING_IA5 = "IA5String"
        STRING_GRAPH = "GraphicString"
        STRING_BMP = "BMPString"
        STRING_GEN = "GeneralString"
        STRING_UNI = "UniversalString"
        STRING_UTF8 = "UTF8String"
        STRING_CHAR = "CHARACTER STRING"
        /* other keywords */
        TAGS = "TAGS"
        EXPORTS = "EXPORTS"
        IMPORTS = "IMPORTS"
        CONTAINING = "CONTAINING"
        TYPE_IDENTIFIER = "TYPE-IDENTIFIER"
        /* brackets */
        LPAREN = "("
        RPAREN = ")"
        LBRACE = "{"
        RBRACE = "}"
        LBRACKET = "["
        RBRACKET = "]"
        /* Operators */
        ASSIGMENT = "::="
        VAR = "&"
        /* Symbols */
        COMMA = ","
        SEMICOLON = ";"
        COLON = ":"
        DOT = "."
        DOUBLE_DOT = ".."
        OR = "|"
        DOUBLE_QUOTE = "\""
        MINUS = "-"
        AT = "@"
        /* comments */
        COMMENT_LINE = "regexp:---.*"
        COMMENT_HEADER = "regexp:--.*"
        COMMENT_MULTILINE = "regexp:/\*[\s\S]*?\*/"
        /* Date and Time */
        TIME_UTC = "UTCTime"
        TIME_GEN = "GeneralizedTime"
        TIME = "TIME"
        TIME_OF_DAY = "TIME-OF-DAY"
        DATE = "DATE"
        DATE_TIME = "DATE-TIME"
        DURATION = "DURATION"
        /* Identifiers */
        VALUE_REF = "regexp:[A-Z]([A-Za-z])*"
        VALUE_NAME = "regexp:\p{Ll}(-|\d|\p{Ll}|\p{Lu})*"
        VALUE_CLASS = "regexp:\p{Lu}(\p{Lu})*"
        /* Primitive */
        STR_LITERALS = "regexp:\"[^\"]*\""
        NUMBER_INT = "regexp:[0-9]+"
        NUMBER_FLOAT = "regexp:\d/.(\d)* "
        /* white space */
        NEW_LINE = "regexp:(\r|\n|\r\n)"
        WHITE_SPACE = "regexp:[\s\t\f\x0B]"
        EMPTY_ELEMENT = "regexp:\x05"
  ]

  generateTokenAccessors=true
}
program                         ::= NEW_LINE* file_header
file_header                     ::= VALUE_REF DEFINITIONS IMPLICIT TAGS ASSIGMENT BEGIN exports_ imports_? constructs_ { pin=6 }
/* elements */
values_                         ::= VALUE_REF|VALUE_NAME
int_round                       ::= LPAREN NUMBER_INT RPAREN { pin=1 }
int_square                      ::= LBRACKET NUMBER_INT RBRACKET { pin=1 }
range_                          ::= LPAREN NUMBER_INT DOUBLE_DOT NUMBER_INT RPAREN { pin=1 }
size_range                      ::= LPAREN SIZE range_ RPAREN { pin=1 }
integer_range                   ::= INTEGER range_
primitive                       ::= INTEGER|BOOLEAN|REAL|NULL
/* export & import */
exports_                        ::= EXPORTS {(TAGGED|values_) COMMA}* (TAGGED|values_) SEMICOLON { pin=1 }
imports_                        ::= IMPORTS from_* SEMICOLON { pin=1 }
from_                           ::= (TAGGED|values_) {COMMA (TAGGED|values_)}* FROM VALUE_REF
/* constructors */
constructs_                     ::= value_assigment|tagged_assigment
value_assigment                 ::= VALUE_REF ASSIGMENT (body_choice|body_enum|body_sequence) { pin=2 }
/* bodies */
body_choice                     ::= CHOICE LBRACE choice_element {COMMA choice_element}* RBRACE { pin=2 }
choice_element                  ::= VALUE_NAME int_square (VALUE_REF|type_string|primitive)
type_string                     ::= STRING_NUM|STRING_PR|STRING_TELE| STRING_VTEXT|STRING_VIS|STRING_IA5|STRING_GRAPH|
                                    STRING_BMP|STRING_GEN|STRING_UNI|STRING_UTF8|STRING_CHAR size_range?

body_enum                       ::= ENUMERATED LBRACE enum_element {COMMA enum_element}* RBRACE { pin=2 }
enum_element                    ::= VALUE_NAME int_round

body_sequence                   ::= SEQUENCE LBRACE (variable_seq {COMMA variable_seq}*)|seq_of RBRACE { pin=2 }
variable_seq                    ::= VALUE_NAME int_square? (VALUE_REF|type_string|integer_range) OPTIONAL?
seq_of                          ::= SEQUENCE OF VALUE_REF { pin=2 }

tagged_assigment                ::= values_ TAGGED ASSIGMENT body_tagged { pin=3 }

body_tagged                     ::= LBRACE (variable_or|oid_) RBRACE
variable_or                     ::= VALUE_NAME {OR VALUE_NAME}*
oid_                            ::= OID LBRACE VALUE_NAME RBRACE






